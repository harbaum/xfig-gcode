/*
 * TransFig: Facility for Translating Fig code
 * Copyright (c) 1991 by Micah Beck
 * Parts Copyright (c) 1985-1988 by Supoj Sutanthavibul
 * Parts Copyright (c) 1989-2002 by Brian V. Smith
 * Parts of this gcode driver are (c) 2007 by Till Harbaum
 *
 * Any party obtaining a copy of these files is granted, free of charge, a
 * full and unrestricted irrevocable, world-wide, paid up, royalty-free,
 * nonexclusive right and license to deal in this software and
 * documentation files (the "Software"), including without limitation the
 * rights to use, copy, modify, merge, publish and/or distribute copies of
 * the Software, and to permit persons who receive copies from any such 
 * party to do so, with the only requirement being that this copyright 
 * notice remain intact.
 *
 */

#include <stdarg.h>
#include <stdio.h>

#include "fig2dev.h"
#include "object.h"

#include <getopt.h>
#include <locale.h>
#include <ft2build.h>
#include FT_FREETYPE_H
#include FT_OUTLINE_H


/* configuration */
#define ARC_STEP    (M_PI / 16)  /* Make a circle to be a 32-gon */
// #define OUTPUT_LINES 
#define LINE_STEP 10

#define ngc_msg(a, args...)    put_msg(a, ##args)
// #define ngc_msg(f, args...)    printf(f "\n", ##args)

#define NYI(a)  put_msg("Not yet implemented: %s", a)

#define ZMUL   25.4
#define XMUL   25.4
#define YMUL   25.4
#define PREC  "%.4f"  // 1/10000 inch

#define FREE_HEIGHT  (ZMUL/2.5)   // ~1cm
// #define FEED_RATE    "1000"       // 25.4 m/min !!!!

// 500-700 mm/min = 20-28 in/min
#define FEED_RATE  "20"  // (500/25.4)

/* the following is placed in front of the file in order to initialize the machine */
static const char *gcode_start[] = { 
  "(gcode generated by xfig, imperial)",
  "G17 G21 G40 G49 (XY plane select, metric mm mode, cancel diameter "
        "comp, cancel length offset)",
  "G54 G80 G90 G94 (coordinate system 1, cancel motion, "
            "non-incremental motion, feed/minute mode)",
  "S1000 M3 M8 (spindle CW, coolant ON, change as required)",
  "F" FEED_RATE " (set feed rate in inch/minute)",
  "G00 X0 Y0",
  ""
};

/* the following is placed at the end of the file to return to idle mode */
static const char *gcode_end[] = {
  "G00 Z1",
  "G00 X0 Y0",
  //  "G0 Z0.25 (rapid to .25\" above the part, change as required)", 
  "M05 M09 (spindle and coolant off)",
  //  "G53 G0 Z0 (temporarily cancel offsets, retract quill)",
  //  "X0. Y0. (move X and Y to the tool change position, change as required)",
  "T0 M6 (remove tool)",
  //  "(MSG,Remove tool)",
  //  "M00 (don't do anything until operator presses the S key)",
  "G49 (cancel length offset)",
  "M2 (end program)",
  ""
};

static int line_counter;

static void ngc_out(const char *format, ...) {
  va_list ap;
  va_start(ap, format);

#ifdef OUTPUT_LINES
  fprintf(tfp, "N%05u ", line_counter);
  line_counter += LINE_STEP;
#endif

  vfprintf(tfp, format, ap);
  va_end(ap);

  fprintf(tfp, "\n");
}

static void gengcode_option(opt, optarg)
char opt, *optarg;
{
  switch (opt) {
  case 'h':
    ngc_msg("HILFE!!");
    exit(1);
    break;
  }
}

static void tool_down(int depth) {
  ngc_out("G01 Z" PREC, (depth-50.0)*-0.01*ZMUL);
}

static void tool_up(void) {
  ngc_out("G00 Z" PREC, FREE_HEIGHT);  /* lift tool */
}

/* we re-arrange the objects internally in our own format to be able to sort */
/* them (e.g. by width to reduce tool changes) */
typedef struct pos {
  double x, y;
  struct pos *next; 
} pos_t;

/* structure to hold a single object */
typedef struct obj {
  pos_t *pos;   /* chain of points (e.g. for g01) */
  int depth;
  struct obj *next;
} obj_t;

/* structure to hold chain of objects using the same tool */
typedef struct tool_chain {
  int tool;
  obj_t *objs;
  struct tool_chain *next;
} tool_chain_t;

tool_chain_t *tool_chains = NULL;

obj_t *new_object(int depth) {
  obj_t *obj = malloc(sizeof(obj_t));
  memset(obj, 0, sizeof(obj_t));

  obj->depth = depth;

  /* all pointers are invalidated by the memset above */

  return obj;
}

void attach_object_to_chain(obj_t **objs, obj_t *obj) {
  //  printf("attaching to chain\n");

  /* walk to end of chain */
  while(*objs) 
    objs = &((*objs)->next);
    
  /* and attach it */
  *objs = obj;
}

void attach_object(obj_t *obj, int tool) {
  tool_chain_t *new_tool_chain, **tool_chain = &tool_chains;

  /* search for machine object chain for this tool */
  while(*tool_chain) {
    /* found matching chain? use it! */
    if((*tool_chain)->tool == tool) {
      attach_object_to_chain(&(*tool_chain)->objs, obj);
      return;
    }
    
    tool_chain = &((*tool_chain)->next);
  }

  /* allocate a new toolchain struct */
  new_tool_chain = malloc(sizeof(tool_chain_t));
  memset(new_tool_chain, 0, sizeof(tool_chain_t));
  new_tool_chain->tool = tool;

  /* and try to insert it at the right place in the chain */
  tool_chain = &tool_chains;  
  while(*tool_chain) {

    if(((*tool_chain)->tool < tool) && 
       ((!(*tool_chain)->next) ||
	((*tool_chain)->next->tool > tool))) {
      new_tool_chain->next = (*tool_chain)->next;
      (*tool_chain)->next = new_tool_chain;
      attach_object_to_chain(&new_tool_chain->objs, obj);      
      return;
    }

    tool_chain = &((*tool_chain)->next);
  }

  *tool_chain = new_tool_chain;
  attach_object_to_chain(&new_tool_chain->objs, obj);      
}

void add_pos(obj_t *obj, double x, double y) {
  pos_t **opos, *pos = malloc(sizeof(pos_t));
  memset(pos, 0, sizeof(pos_t));

  pos->x = XMUL * x;
  pos->y = YMUL * y;

  /* attach to chain of positions */
  opos = &obj->pos;
  while(*opos)
    opos = &((*opos)->next);

  *opos = pos;
}

/* make an object being milled from end to start */
/* (used for path optimizations) */
void reverse_object(obj_t *obj) {
  pos_t *pos = obj->pos;
  pos_t *new_chain = NULL;

  while(pos) {
    pos_t *tmp = pos->next;

    /* take from begin of original chain and attach to begin of new chain */
    /* (yes, this reverses the order) */
    pos->next = new_chain;
    new_chain = pos;

    pos = tmp;
  }
  
  obj->pos = new_chain;
}

int is_in_line(pos_t *a, pos_t *b, pos_t *c) {
  //  printf("check for in_line %p/%f/%f -> %p/%f/%f -> %p/%f/%f\n", 
  //	 a, a->x, a->y, b, b->x, b->y, c, c->x, c->y);

  /* make sure all points are valid */
  if(!a || !b || !c) return 0;

  /* all horizontally aligned */
  if((a->x == b->x) && (a->x == c->x)) return 1;

  /* all vertically aligned */
  if((a->y == b->y) && (a->y == c->y)) return 1;

  double m = (b->x - a->x)/(c->x - a->x);
  double by = a->y + m * (c->y - a->y);

  return by == b->y;
}

pos_t *get_prev_pos(obj_t *obj, pos_t *pos) {
  pos_t *this_pos = obj->pos;

  while(this_pos->next && (this_pos->next != pos))
    this_pos = this_pos->next;

  return this_pos;
}

pos_t *get_last_pos(obj_t *obj) {
  pos_t *this_pos = obj->pos;

  while(this_pos->next)
    this_pos = this_pos->next;

  return this_pos;
}

int get_obj_positions(obj_t *obj) {
  pos_t *this_pos = obj->pos;
  int len = 0;

  while(this_pos->next) {
    this_pos = this_pos->next;
    len++;
  }

  return len;
}

/* try to join seperate paths into single bigger ones */
int join_objects(int in_line) {
  tool_chain_t *tool_chain = tool_chains;
  int destroyed, joined = 0;

  /* walk through all tool chains */
  while(tool_chain) {
    obj_t **obj = &tool_chain->objs;

    //    printf("**** TOOL %d ************\n", tool_chain->tool);

    while(*obj) {
      destroyed = 0;

      /* get first point of object */
      pos_t *e_pos, *pos = (*obj)->pos;
      e_pos = get_last_pos(*obj);

      /* and search through all other objects to check if they */
      /* can be connected, search only at same tool */
      obj_t *comp_obj = tool_chain->objs;
      while(comp_obj) {

	/* don't try to connect object with itself or with object at */
	/* at different depth */
	if((comp_obj != (*obj)) && (comp_obj->depth == (*obj)->depth)) {
	  pos_t *comp_pos = comp_obj->pos;
	  pos_t *comp_e_pos = get_last_pos(comp_obj);

	  if(((comp_e_pos->x == pos->x) && (comp_e_pos->y == pos->y)) ||
	     ((comp_e_pos->x == e_pos->x) && (comp_e_pos->y == e_pos->y)) ||
	     ((comp_pos->x == pos->x) && (comp_pos->y == pos->y))) {

	    if((comp_e_pos->x == pos->x) && (comp_e_pos->y == pos->y)) {
	      //	      printf("  can be attached to end\n");
	    } else if((comp_pos->x == pos->x) && (comp_pos->y == pos->y)) {
	      //	      printf("  can be attached to end of reversed\n");
	      reverse_object(comp_obj);
	      
	      /* update start and end positions */
	      comp_pos = comp_obj->pos;
	      comp_e_pos = get_last_pos(comp_obj);
	    } else {
	      //	      printf("  can be reverse attached to end\n");
	      reverse_object(*obj);
	      
	      /* update start and end positions */
	      pos = (*obj)->pos;
	      e_pos = get_last_pos(*obj);
	    }

	    /* find the position before comp_pos_e */
	    pos_t *comp_e_pos_prev = get_prev_pos(comp_obj, comp_e_pos);

	    if(!in_line || is_in_line(comp_e_pos, comp_e_pos_prev, pos->next)) {

	      /* de-chain current object */
	      //	      printf("de-chain object\n");
	    
	      /* omit first point as it's the same as the last one of the */
	      /* chain we are attaching to */
	      pos = (*obj)->pos->next;
	      free((*obj)->pos);

	      /* if this is a "in_line" join, we can omit both matching ends*/
	      if(in_line) {
		pos_t *pre_pos = get_prev_pos(comp_obj, comp_e_pos);

		/* just forget following position */
		free(pre_pos->next);
		pre_pos->next = NULL;

		comp_e_pos = get_last_pos(comp_obj);

		//		printf("got previous at %p\n", pre_pos);
	      }

	      /* attach remaining chain */
	      comp_e_pos->next = pos;
	      
	      /* free the now superfluous object */
	      obj_t *dc_obj = *obj;
	      *obj = (*obj)->next;
	      free(dc_obj);
	      
	      /* remember that we destroyed this object */
	      destroyed = 1;
	      
	      joined++;
	    }
	  }
	}

	/* compare with next object if this object hasn't been destroyed */
	comp_obj = (!destroyed)?comp_obj->next:NULL;
      }

      /* if object has been destroyed, the next pointer has already */
      /* been advanced */
      if(!destroyed)
	obj = &(*obj)->next;
    }

    tool_chain = tool_chain->next;
  }

  return joined;
}


void output_objects(void) {
  tool_chain_t *tool_chain = tool_chains;
  pos_t *pos;

  /* walk through all tool chains */
  while(tool_chain) {
    //    printf("Output with tool %d\n", tool_chain->tool);

    /* sort objects by depth, starting with the least depth ones */
    obj_t *new = NULL;
    obj_t *obj = tool_chain->objs;

    while(obj) {
      obj_t *next = obj->next;
      obj_t **tmp = &new;

      /* walk new chain as long as objects are less deep than current one */
      while(*tmp && (*tmp)->depth < obj->depth)
	tmp = &(*tmp)->next;

      obj->next = *tmp;
      *tmp = obj;

      obj = next;
    }

    obj = tool_chain->objs = new;

    /* change tool */
    ngc_out("T%u M06 G43 H%u (change to tool %u and get its length "
	    "from the tool table)", 
	    tool_chain->tool, tool_chain->tool, tool_chain->tool);
    
    /* walk through chain of objects */
    while(obj) {
      int len=0;
      pos = obj->pos;
      while(pos->next) { pos = pos->next; len++; }

      pos = obj->pos;
      ngc_out("G00 X" PREC " Y" PREC , pos->x, pos->y);
      tool_down(obj->depth);
      while(pos->next) {
	pos = pos->next;
	ngc_out("G01 X" PREC " Y" PREC , pos->x, pos->y);
      }
      tool_up();
      obj = obj->next;
    }
    tool_chain = tool_chain->next;
  }
}

void free_all(void) {
  tool_chain_t *tool_tmp, *tool_chain = tool_chains;

  //   printf("freeing everything\n");

  /* walk through chain of tools */
  while(tool_chain) {
    obj_t *obj_tmp, *obj = tool_chain->objs;

    /* walk through chain of objects */
    while(obj) {
      pos_t *pos_tmp, *pos = obj->pos;

      /* walk through chain of positions */
      while(pos) {
	pos_tmp = pos;
	pos = pos->next;
	free(pos_tmp);
      } 

      obj_tmp = obj;
      obj = obj->next;
      free(obj_tmp);
    }

    tool_tmp = tool_chain;
    tool_chain = tool_chain->next;
    free(tool_tmp);
  }

  //  printf("done\n");
}

void gc_arc(obj_t *obj, double sx, double sy, double cx, double cy, 
	 double theta, double delta)
{
  double	alpha;
  if (theta < 0.0)
    delta = -fabs(delta);
  else
    delta = fabs(delta);
  for (alpha = delta; fabs(alpha) < fabs(theta); alpha += delta) {
    add_pos(obj, 
	    cx + (sx - cx)*cos(alpha) - (sy - cy)*sin(alpha),
	    cy + (sy - cy)*cos(alpha) + (sx - cx)*sin(alpha));
  }
  add_pos(obj, 
	  cx + (sx - cx)*cos(theta) - (sy - cy)*sin(theta),
	  cy + (sy - cy)*cos(theta) + (sx - cx)*sin(theta));
}

void gengcode_arc(a)
    F_arc	*a;
{
  obj_t *obj = new_object(a->depth);

  double	cx, cy, sx, sy, ex, ey;
  double	dx1, dy1, dx2, dy2, theta;

  cx		 = a->center.x   * mag / ppi;
  cy		 = a->center.y   * mag / ppi;
  sx		 = a->point[0].x * mag / ppi;
  sy		 = a->point[0].y * mag / ppi;
  ex		 = a->point[2].x * mag / ppi;
  ey		 = a->point[2].y * mag / ppi;

  dx1		 = sx - cx;
  dy1		 = sy - cy;
  dx2		 = ex - cx;
  dy2		 = ey - cy;
  
  theta	 = atan2(dy2, dx2) - atan2(dy1, dx1);
  if (a->direction) {
    if (theta > 0.0)
      theta	-= 2.0*M_PI;
  } else {
    if (theta < 0.0)
      theta	+= 2.0*M_PI;
  }

  if (a->type == T_PIE_WEDGE_ARC)
    add_pos(obj, cx, cy);
  
  add_pos(obj, sx, sy);
  gc_arc(obj, sx, sy, cx, cy, theta, ARC_STEP);

  if (a->type == T_PIE_WEDGE_ARC)
    add_pos(obj, cx, cy);
  
  attach_object(obj, a->thickness/15);
}


void gengcode_ellipse(e)
    F_ellipse	*e;
{
  double x0, y0;
  double rx, ry;
  double angle, theta;
  obj_t *obj;

  obj = new_object(e->depth);

  x0 = e->center.x * mag / ppi;
  y0 = e->center.y * mag / ppi;
  rx = e->radiuses.x * mag / ppi;
  ry = e->radiuses.y * mag / ppi;
  angle = - e->angle;

  //  printf("adding ellipse with radius %f/%f (mag = %f)\n", rx, ry, mag);
 
  for (theta = ARC_STEP/2; theta < 2.0 * M_PI+ARC_STEP/2; theta += ARC_STEP) {
    add_pos(obj, 
	    x0 + cos(angle) * rx * cos(theta) - sin(angle) * ry * sin(theta),
	    y0 + sin(angle) * rx * cos(theta) + cos(angle) * ry * sin(theta));
  }

  add_pos(obj, 
   x0 + cos(angle) * rx * cos(ARC_STEP/2) - sin(angle) * ry * sin(ARC_STEP/2),
   y0 + sin(angle) * rx * cos(ARC_STEP/2) + cos(angle) * ry * sin(ARC_STEP/2));

  attach_object(obj, e->thickness/15);
}

void gengcode_line(l)
    F_line	*l;
{
  F_point	*p;
  obj_t *obj;

  /* walk through list of points */
  p	 = l->points;

  switch (l->type) {
  case	T_POLYLINE:
  case	T_PIC_BOX:
  case	T_BOX:
  case	T_POLYGON:
    obj = new_object(l->depth);

    /* move fast to first point */
    add_pos(obj, p->x*mag/ppi, p->y*mag/ppi);

    /* and move to the next points at working speed */
    while (p->next != NULL) {
      p	 = p->next;
      add_pos(obj, p->x*mag/ppi, p->y*mag/ppi);
    }
    
    attach_object(obj, l->thickness/15);
    break;
    
  case	T_ARC_BOX:
    obj = new_object(l->depth);

    double xmin, xmax, ymin, ymax;
    double x, y, r, theta;
 
    xmin = xmax = l->points->x * mag / ppi;
    ymin = ymax = l->points->y * mag / ppi;
    for (p = l->points->next; p != NULL; p = p->next) {
      if (p->x * mag / ppi < xmin) xmin = p->x * mag / ppi;
      if (xmax < p->x * mag / ppi) xmax = p->x * mag / ppi;
      if (p->y * mag / ppi < ymin) ymin = p->y * mag / ppi;
      if (ymax < p->y * mag / ppi) ymax = p->y * mag / ppi;
    }
    
    r = l->radius * mag / ppi;

    /* corner radius cannot be more than half of one side */
    r = MIN(r,(xmax-xmin)/2);
    r = MIN(r,(ymax-ymin)/2);

    /* define macro for the corner arc */                        
#define ARCCORNER(FIN_ANGLE) while(theta<(FIN_ANGLE)) { \
                             add_pos(obj, x+r*cos(theta), y+r*sin(theta));\
                             theta+=ARC_STEP; } \
                             add_pos(obj, x+r*cos(theta), y+r*sin(theta));

    x = xmax-r;
    y = ymax-r;
    theta=0;
    ARCCORNER(M_PI/2);
    /* lower right corner */
    
    x=xmin+r;
    ARCCORNER(M_PI);
    /* lower left corner */
    
    y=ymin+r;
    ARCCORNER(3*M_PI/2);
    /* upper left corner */
    
    x=xmax-r;
    ARCCORNER(2*M_PI);
    /* upper right corner */

    /* and close object */
    add_pos(obj, xmax, ymax-r);

    attach_object(obj, l->thickness/15);
    break;
    
  }
}

void gengcode_spline(s)
F_spline	*s;
{
  ngc_msg("gengcode_spline()");
}

/* path to the ghostscript fonts */
#define TTFONTPATH  "/usr/share/fonts/type1/gsfonts/"

/* the real names of the ghostscipt fonts */
char *gs_font_name[] = {
  /* Times 0..3 */
  "n021003l.pfb", /* -adobe-times-medium-r-normal--0-0-0-0-p-0-iso8859-1 */
  "n021023l.pfb", /* -adobe-times-medium-i-normal--0-0-0-0-p-0-iso8859-1 */
  "n021004l.pfb", /* -adobe-times-bold-r-normal--0-0-0-0-p-0-iso8859-1 */
  "n021024l.pfb", /* -adobe-times-bold-i-normal--0-0-0-0-p-0-iso8859-1 */
  /* Avantgarde 0..3 */
  "a010013l.pfb", /* -adobe-avantgarde-book-r-normal--0-0-0-0-p-0-iso8859-1 */
  "a010033l.pfb", /* -adobe-avantgarde-book-o-normal--0-0-0-0-p-0-iso8859-1 */
  "a010015l.pfb", /* -adobe-avantgarde-demi-r-normal--0-0-0-0-p-0-iso8859-1 */
  "a010035l.pfb", /* -adobe-avantgarde-demi-o-normal--0-0-0-0-p-0-iso8859-1 */
  /* Bookman 0..3 */
  "b018012l.pfb", /* -adobe-bookman-light-r-normal--0-0-0-0-p-0-iso8859-1 */
  "b018032l.pfb", /* -adobe-bookman-light-i-normal--0-0-0-0-p-0-iso8859-1 */
  "b018015l.pfb", /* -adobe-bookman-demi-r-normal--0-0-0-0-p-0-iso8859-1 */
  "b018035l.pfb", /* -adobe-bookman-demi-i-normal--0-0-0-0-p-0-iso8859-1 */
  /* Courier 0..3 */
  "n022003l.pfb",  /* Nimbus mono */
  "n022023l.pfb",
  "n022004l.pfb",
  "n022024l.pfb",
  /* Helvetica 0..3 */
  "n019003l.pfb", /* -adobe-helvetica-medium-r-normal--0-0-0-0-p-0-iso8859-1 */
  "n019023l.pfb", /* -adobe-helvetica-medium-o-normal--0-0-0-0-p-0-iso8859-1 */
  "n019004l.pfb", /* -adobe-helvetica-bold-r-normal--0-0-0-0-p-0-iso8859-1 */
  "n019024l.pfb", /* -adobe-helvetica-bold-o-normal--0-0-0-0-p-0-iso8859-1 */
  /* Helvetica narrow 0..3 */
  "n019043l.pfb", /* -adobe-helvetica-medium-r-narrow--0-0-0-0-p-0-iso8859-1 */
  "n019063l.pfb", /* -adobe-helvetica-medium-o-narrow--0-0-0-0-p-0-iso8859-1 */
  "n019044l.pfb", /* -adobe-helvetica-bold-r-narrow--0-0-0-0-p-0-iso8859-1 */
  "n019064l.pfb", /* -adobe-helvetica-bold-o-narrow--0-0-0-0-p-0-iso8859-1 */
  /* New Century Schoolbook 0..3 */
  "c059013l.pfb", /* -adobe-new century schoolbook-medium-r-normal--0-0-0-0-p-0-iso8859-1 */
  "c059016l.pfb", /* -adobe-new century schoolbook-bold-r-normal--0-0-0-0-p-0-iso8859-1 */
  "c059033l.pfb", /* -adobe-new century schoolbook-medium-i-normal--0-0-0-0-p-0-iso8859-1 */
  "c059036l.pfb", /* -adobe-new century schoolbook-bold-i-normal--0-0-0-0-p-0-iso8859-1 */
  /* Palatino 0..3 */
  "p052003l.pfb", /* -adobe-palatino-medium-r-normal--0-0-0-0-p-0-iso8859-1 */
  "p052023l.pfb", /* -adobe-palatino-medium-i-normal--0-0-0-0-p-0-iso8859-1 */
  "p052004l.pfb", /* -adobe-palatino-bold-r-normal--0-0-0-0-p-0-iso8859-1 */
  "p052024l.pfb", /* -adobe-palatino-bold-i-normal--0-0-0-0-p-0-iso8859-1 */
  /* Symbol */
  "s050000l.pfb", /* this one doesn't work ... */
  /* Zapf Chancery */
  "z003034l.pfb", /* -adobe-itc zapf chancery-medium-i-normal--0-0-0-0-p-0-iso8859-1 */
  /* Zapf Dingbats */
  "d050000l.pfb"
};

#define NUM_FONTS (sizeof(gs_font_name)/sizeof(char*))

static FT_Library ft_library;
static FT_Face ft_face[NUM_FONTS];

#undef __FTERRORS_H__
#define FT_ERRORDEF( e, v, s )  { e, s },
#define FT_ERROR_START_LIST     {
#define FT_ERROR_END_LIST       { 0, 0 } };

const struct ftError {
  int          err_code;
  const char*  err_msg;
} ft_errors[] =
#include FT_ERRORS_H

typedef struct {
  FT_Vector p0;      /* position of last point (req. for splines) */
  obj_t *text_obj;   /* pointer to current gcode chain object */
  F_text *t;         /* pointer to current xfig text object */
  int offset;        /* offset of current character with string */
} ft_state_t;

/* freetype error handler */
void ft_err(int err_code, char *err_msg) {
  const struct ftError *err = ft_errors;

  /* search for error code in list */
  while(err->err_msg && err->err_code != err_code) err++;

  if(err->err_msg) {
    fprintf(stderr, "Freetype error %d in %s: %s\n", 
	    err_code, err_msg, err->err_msg);
    return;
  }

  fprintf(stderr, "Freetype error %d in %s\n", err_code, err_msg);
}

void text_add_pos(ft_state_t *state, double x, double y) {
  double rot_x, rot_y;

  /* Add character offset ... */
  x += state->offset;

  /* ... scale, ... */
  /* TODO: try to actually calculate factor */
  /* 0.224 / pixel_size, take ppi+mag into account??? */
  x *= state->t->size * 0.0035;  /* * (pxl size = 64) = 0.224 in xfig units */
  y *= state->t->size * 0.0035;

  /* ... shift, ... */
  if(state->t->type == T_CENTER_JUSTIFIED)
    x -= state->t->length/2;

  if(state->t->type == T_RIGHT_JUSTIFIED) 
    x -= state->t->length;

  /* ... rotate, ... */
  rot_x =  x *  cos(state->t->angle) +  y * -sin(state->t->angle);
  rot_y =  y * -cos(state->t->angle) +  x * -sin(state->t->angle);

  /* ... and move to final position */
  rot_x += state->t->base_x;
  rot_y += state->t->base_y;

  add_pos(state->text_obj, rot_x * mag / ppi, rot_y * mag / ppi);
}

static void ft_position_save(ft_state_t *state, const FT_Vector* p) {
  state->p0.x = p->x;
  state->p0.y = p->y;
}

/* start a new object at given position */
static int ft_move_to(const FT_Vector* p1, void* user ) {
  ft_state_t *state = (ft_state_t*)user;

  /* close previous object if required */
  if(state->text_obj) {
    attach_object(state->text_obj, 1);  /* texts don't have a thickness ... */
    state->text_obj = NULL;
  }

  /* every ft_move_to starts a new object */
  state->text_obj = new_object(state->t->depth);

  /* add first point */
  text_add_pos(state, p1->x, p1->y);
  ft_position_save(state, p1);
  
  return 0;
}

/* just do a straight line */
static int ft_line_to(const  FT_Vector* p1, void* user ) {
  ft_state_t *state = (ft_state_t*)user;

  text_add_pos(state, p1->x, p1->y);
  ft_position_save(state, p1);

  return 0;
}

// define the number of linear segments we use to approximate beziers
// in the gcode
#define CSTEPS 8
#define CUBIC_STEP (1.0/CSTEPS)

/* the postscript fonts we are using use cubic splines only */
static int ft_cubic_to(const FT_Vector* p1, const FT_Vector* p2,
		       const FT_Vector *p3, void* user) {
  ft_state_t *state = (ft_state_t*)user;
  double step;

  for(step=CUBIC_STEP;step<=1.0;step+=CUBIC_STEP) {
    /* DeCasteljau: (1-step)^3*P0 + 3*(1-step)^2*step*P1 + */
    /*                    3*(1-step)*step^2*P2 + step^3*P3 */
    double s0 =     pow(1.0-step, 3);
    double s1 = 3 * pow(1.0-step, 2) *     step;
    double s2 = 3 *    (1.0-step)    * pow(step, 2);    
    double s3 =                        pow(step, 3);    

    text_add_pos(state,
		 s0 * state->p0.x + s1 * p1->x + s2 * p2->x + s3 * p3->x,
		 s0 * state->p0.y + s1 * p1->y + s2 * p2->y + s3 * p3->y);
  }

  ft_position_save(state, p3);
  return 0;
}

void gengcode_text(F_text *t) {
  int bytes, err, glyph;
  char ttfont[128], *s;
  wchar_t wchr;
  ft_state_t state;

  FT_Outline_Funcs ofunc = {
    .move_to = ft_move_to,
    .line_to = ft_line_to,
    .cubic_to = ft_cubic_to
  };

  if(!ft_library) return;

  /* keep track of text state */
  state.t = t;
  state.text_obj = NULL;
  state.offset = 0;

  /* build font name */
  if(t->font < 0) t->font = 0;     /* default is first */
  if((int)t->font >= NUM_FONTS) return;
  
  if(!ft_face[t->font]) {
    /* build full font name */
    strcpy(ttfont, TTFONTPATH);
    strcat(ttfont, gs_font_name[t->font]);
    
    if((err = FT_New_Face(ft_library, ttfont, 0, &ft_face[t->font]))) {
      ft_err(err, "FT_New_Face");
      return;
    }
    
    /* use size 64, all pre-defined fonts can be scaled */
    if((err = FT_Set_Pixel_Sizes(ft_face[t->font], 0, 64))) {
      ft_err(err, "FT_Set_Pixel_Sizes");
      return;
    }

#if 1
    {
      FT_ULong  charcode;
      FT_UInt   gindex;
      char buffer[128];

      printf("Loading font %s\n", FT_Get_Postscript_Name(ft_face[t->font]));

      charcode = FT_Get_First_Char( ft_face[t->font], &gindex );
      while ( gindex != 0 ) {
	printf("char %ld at index %d: ", charcode, gindex);
	charcode = FT_Get_Next_Char( ft_face[t->font], charcode, &gindex );

	FT_Get_Glyph_Name(ft_face[t->font], gindex, buffer, sizeof(buffer));
	printf("%s\n", buffer);
      }
    }
#endif  
  }
    
  /* process one character after the other */
  for(s = t->cstring; *s ; s+=bytes) {
    bytes = mbtowc(&wchr, s, strlen(s));
    
    if(wchr && bytes>0) {
      if(!(glyph = FT_Get_Char_Index(ft_face[t->font], (FT_ULong)wchr))) 
      	ngc_msg("Unable to process character %d in font %s (%s)", 
      		wchr, FT_Get_Postscript_Name(ft_face[t->font]), 
		gs_font_name[t->font]);
      else {
	/* load glyph */
	if((err = FT_Load_Glyph(ft_face[t->font], glyph, FT_LOAD_NO_BITMAP))) 
	  ft_err(err, "FT_Load_Glyph");
	else {
	  /* draw character outlines using our own primitives */
	  if((err = FT_Outline_Decompose( &ft_face[t->font]->glyph->outline, 
					  &ofunc, &state))) 
	    ft_err(err, "FT_Outline_Decompose");
	  else {
	    /* advance by characters width */
	    state.offset += ft_face[t->font]->glyph->advance.x;
	  }
	}
      }
    } else
      bytes = 1;  /* skip unprocessable character */
  }

  /* close previous object if required */
  if(state.text_obj) 
    attach_object(state.text_obj, 1);  /* xfig texts don't have a thickness */
}

void gengcode_start(objects) 
F_compound	*objects;
{
  int i;
  int err;

  /* initialize freetype library */
  if((err = FT_Init_FreeType(&ft_library))) {
    ft_err(err, "FT_Init_FreeType");
    ft_library = NULL;
  }
  
  for(i=0;i<NUM_FONTS;i++)
    ft_face[i] = NULL;

  line_counter = 0;

  /* write pre-defined GCODE start sequence */
  i = 0;
  while(gcode_start[i][0]) 
    ngc_out(gcode_start[i++]);

  tool_up();
}

int
gengcode_end()
{
  int i = 0;

  /* join as many elements as possible */

  /* first prio: in_line connections */
  do 
    i = join_objects(1);
  while(i);

  /* second prio: all other connections */
  do 
    i = join_objects(0);
  while(i);

  output_objects();

  /* GCODE ending */
  i = 0;
  while(gcode_end[i][0])
    ngc_out(gcode_end[i++]);

  free_all();

  /* all ok */
  return 0;
}

struct driver dev_gcode = {
     	gengcode_option,
	gengcode_start,
	gendev_null,      /* grid */
	gengcode_arc,
	gengcode_ellipse,
	gengcode_line,
	gengcode_spline,
	gengcode_text,
	gengcode_end,
	INCLUDE_TEXT
	};
